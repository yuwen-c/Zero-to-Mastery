## front end
- components, layout.
- add functionality(button, input. onChange, onClick)
- connect API (face-recognition)

## routing
- a plan for signIn, signOut: where should it go? what navigation should be put on the screen?
- add a route function with page parameter to direct to that page.      
***an arrow function in child component is needed***

## server end    
***run ```npm init``` to get ```package.json```***    
***install nodemon to monitor changes and run it automatically.*** (```--save-dev``` and ```"start" : "nodemon script.js"```)    
***install express to build a server***   

- a plan. what route, what method, bear what data, in head or body, url, response?
- base on the plan, write routes.
- test them with postman
- a fake database is needed. think of a table as an array, every row of data is an object.
- think what data you need to store, in what knid of type.    
***on server end, console.log will be in terminal of server***   
```
const database = {
    users:[
        {
            id: 123,
            name: "Judy",
            email: "judy@gmail.com",
            password: "123",
            entries: 0,
            joined: new Date()
        },
        {
            id: 124,
            name: "David",
            email: "david@gmail.com",
            password: "124",
            entries: 0,
            joined: new Date()
        }
    ],
    login:[
        {
            id: 123,
            password: ""
        },
        {
            id: 124,
            password: ""
        }
    ]
}
```
## connect server end to front end     
***install cors (伺服器端存取控制) to allow to connect front end to server with HTTP***       
- run one on port 3000 and the other on 3001
- test it with ```componentDidMount``` and ```fetch``` to see if they are connected
- deal with the input information in this step, use setState to store input information 
- use certain method to connect to server, like:
```
this.grabFaceFun(response);
fetch('http://localhost:3000/image', {
  method: 'put',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify(this.state.user)
})
```
- trigger parent setState in child component: call a parent function

## database   
***install knex to connect postgresql with server***    
***install bcrypt-nodejs, or latest version bcrypt, to encrypt password***    
- use knex syntax(SQL syntax) to re-write the server

## test it out with fromt end
- test all the buttons, input, links, routes with credentials.

***Missing part: should clear user data after sign out***
- we can assign a initial state to a variable, and every time signning out, setState.


## code review

### extract duplicate code
- sign in and register components have repeated code.
- extract it to another comopnent
***break down components so that they can be reuseable.***
- there are many ways of doing this, here is mine:
  - my first try is extract email and password divs to another component. that's easy.
  ***When you aren't sure what you're going to do, give it a easy try, then expand it***    
  > then I thought, I want it more dry, is it possible to make functions reusable?          
  > also I thought, a divided view is not clear. (In the previous version, I put name div and share component in Register)    
  - so I put 2 views in share component, add a ternary operator in return, but I need a condition to make this => so I pass App route as a prop to Register and next prop to share form. so did in Signin.
  - now, move the input onChange functions to share form.
  > I decided to let the state keep inside of Register and SignIn components.
  - so I add a setState funciton in parent component, pass it, and call it in share component.
  ***here I encounted a problem, a dynamic property name in object. use [ ]***
  - and that's it.
  

### add catch in every fetch. Erroe Handler
- ```fetch```, ```.then``` needs a ```.catch(console.log)``` behind.

### group
- each component stays at it's own folder
- Mainly in an app, codes are put in ```src``` folder.
  - inside of it, a ```container folder``` includes app.js, app.css
  - another ```component folder``` contains small components, ErrorBoundary, Scroll...etc.
  - for a large project, each component has it's own folder.

> <pre>   src -> component -> Logo folder -> Logo.js      
>                                    Logo.css      
>                                    Logo.png      
>                  -> Navigation -> Navigation.js
>                                -> Navigation.css     </pre> 

  - ```index```, and ```serviceWorker.js``` stay in ```src``` folder.

## re-write server-end
- create a controllers folder, put each single route "handler" to it's own file.
  - in the main ```server.js```, we leave:
    ```
    app.post('/signin', (req, res) => signin.handleSignin(req, res, db, bcrypt))  
    ```
  - in the new ```signin.js```, put function code here:
    ```
    const handleSignin = (req, res, db, bcrypt) => {
    
    }
    ```
- then we need to do module exports, and require. (see 63. node.js.md)
- however, some variables are not avaliable: (db, bcrypt)
  - do dependency injection   // like above example


## validation
- validate not only the front end, but also the back end.
***never trust a data passed by front end, back end must do it's own validation***

### validation in front end
- no accept blank input
- a certain format of email
- more than 6 letters password

## security 
- in our previous setting, the clarifai API key was put on front end, when url is sending, anyone can see our key in console(network)
- put these sensitive data in the back end.

### step
- download clarifai in back end
- copy the key to back end
- when doing a fetch to clarifai, we send the face url and key to clarifai server.
  - so now we need that url in backend, which we can send it through another server API endpoint.
```
fetch('server', method...)
.then(response => response.json)
原本是輸入url，submit，這個url連同key被帶往clarifai server.
回傳後1. grabface 將方框顯示在前端。
2. 去database做entries 增加1

現在希望把去clarifai查詢的動作移到後端
當得到方框資訊，回傳前端。
所以我可以利用一個api endpoint，傳入req(url)，得到res(faceRegions)傳回前端。
這樣一來就很清楚了。太好了。



