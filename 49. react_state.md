## state
- state is the description of your App, the state is simply an object that descripbe your application
- the state in this project:
  - {robots}
  - what entered the searchbox
- state can be changed

- props are things that come out of state.
- parent feeds a state to a child, then the child has a property, and it cannot be changed.


## setState
- setState is async function, so we won't get the actual value through ```this.state.```...
- use callback function to get the actual value:
```
this.setState({property: value}, () => console.log(this.state))
```


### ps

This is exactly why setState is async.

React does a bunch of things in the background after it encounters a setState command.

One of the things is, that it awaits until the state receives the new value.

Then it executes the render method which results in a refresh of the data.





## an issue that happened to me
- there is an empty Activity array in state, I want to setState one element at a time, 7 elements in total.  

### first try, const a new empty array and setstate Activity at the end
```
fun = (event) => {
  const newArr = [];
  newArr[index] = event.target.value
  this.setState({Activity : newArr})
}
```
- basically it's wrong, the newArr get restart everytime, and at last I just got one element

### second try, find a solution in stack overflow. New a copy of this.state
- the solution comes from here:    
https://stackoverflow.com/questions/39941734/how-can-i-insert-into-reacts-state-array-with-setstate/39943308#39943308
```
// example code
let new_state = Object.assign({}, this.state); 
let a = new_state.arr;
a[index] = "random element";
this.setState({arr: a});
```
- then I change it to my variables, and it seems work:
  - I can console log this.state.Activity
  - but in render part ```{this.state.Activity} ```does't work
  - only the ```{this.state.Activity[0]}``` can run.
  
- then I suddenly found that, I haven't change one variable: ```this.setState({arr : a})```, it should have been ```this.setState({Activity : a})```
- also, some response below also said that it was a wrong answer, you never mutate a state.

### thrid try, New a copy of this.state with different way
- it's simplier, no Object.assign involved.
```
fun = (event) => {
  let newArr = this.state.Activity;
  newArr[index] = event.target.value
  this.setState({Activity : newArr})
}
```
- it seems work too.
- and I read the most voted answer, which is the next try

### fourth try. New a SEPERATED copy of Activity state.
![pic](https://i.stack.imgur.com/GeeaZ.jpg)
```
// example code
let a = this.state.arr.slice(); //creates the clone of the state
a[index] = "random element";
this.setState({arr: a});
```
- if you directly assign this, it passes by reference. so when you mutate the a variable, state also be changed at the same time
```
let a = this.state.arr
```
- change state w/o using setState, it'll cause unnormal render
- so the right way of copy is a pass by value copy
- in the example, ```slice()``` returns a new array, it makes sure that you don't change state accidentially
```
// eventually, my code is:
fun = (event) => {
  let newArr = this.state.Activity.slice();
  newArr[index] = event.target.value
  this.setState({Activity : newArr})
}
```
- finanlly ```{this.state.Activity}``` renders well
















