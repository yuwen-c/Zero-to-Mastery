## state
- state is the description of your App, the state is simply an object that descripbe your application
- the state in this project:
  - {robots}
  - what entered the searchbox
- state can be changed

- props are things that come out of state.
- parent feeds a state to a child, then the child has a property, and it cannot be changed.


## setState
- setState is async function, so we won't get the actual value through ```this.state.```...
- use callback function to get the actual value:
```
this.setState({property: value}, () => console.log(this.state))
```


### ps

This is exactly why setState is async.

React does a bunch of things in the background after it encounters a setState command.

One of the things is, that it awaits until the state receives the new value.

Then it executes the render method which results in a refresh of the data.





## an issue that happened to me
- there is an empty Activity array in state, I want to setState one element at a time, 7 elements in total.  

### first try, const a new empty array and setstate Activity at the end
```
fun = (event) => {
  const newArr = [];
  newArr[index] = event.target.value
  this.setState({Activity : newArr})
}
```
- basically it's wrong, the newArr get restart everytime, and at last I just got one element

### second try, find a solution in stack overflow. New a copy of this.state
- the solution comes from here:    
https://stackoverflow.com/questions/39941734/how-can-i-insert-into-reacts-state-array-with-setstate/39943308#39943308
```
// example code
let new_state = Object.assign({}, this.state); 
let a = new_state.arr;
a[index] = "random element";
this.setState({arr: a});
```
- then I change it to my variables, and it seems work:
  - I can console log this.state.Activity
  - but in render part ```{this.state.Activity} ```does't work
  - only the ```{this.state.Activity[0]}``` can run.
  
- then I suddenly found that, I haven't change one variable: ```this.setState({arr : a})```, it should have been ```this.setState({Activity : a})```
- also, some response below also said that it was a wrong answer, you never mutate a state.

### thrid try, New a copy of this.state with different way
- it's simplier, no Object.assign involved.
```
fun = (event) => {
  let newArr = this.state.Activity;
  newArr[index] = event.target.value
  this.setState({Activity : newArr})
}
```
- it seems work too.
- and I read the most voted answer, which is the next try

### fourth try. New a SEPERATED copy of Activity state.
![pic](https://i.stack.imgur.com/GeeaZ.jpg)
```
// example code
let a = this.state.arr.slice(); //creates the clone of the state
a[index] = "random element";
this.setState({arr: a});
```
- if you directly assign this, it passes by reference. so when you mutate the a variable, state also be changed at the same time
```
let a = this.state.Activity
```
- change state w/o using setState, it'll cause unnormal render
- so the right way of copy is a pass by value copy
- in the example, ```slice()``` returns a new array, it makes sure that you don't change state accidentially
```
// eventually, my code is:
fun = (event) => {
  let newArr = this.state.Activity.slice();
  newArr[index] = event.target.value
  this.setState({Activity : newArr})
}
```
- finanlly ```{this.state.Activity}``` renders well


## the application of Object.assign
- in smartbrain, after user log in, we got the data of user in our page
- and user passes an url, meanwhile, we connect to database, do the increment, and send back the entries date.
- if we ```the.setState({users:{ entries: data })``` will setState the whole user object, so we lose user name in the screen. 
- so we do:
```
.then(count => this.setState(Object.assign(this.state.user, {entries: count}))) 
```
- ```Object.assign``` assigns a latter object to a former object
- so here we assign the new entries to the original state, which is ```this.state.user```

### ```Object assign```: to combine objects
- https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
```
有相同屬性時合併物件
var o1 = { a: 1, b: 1, c: 1 };
var o2 = { b: 2, c: 2 };
var o3 = { c: 3 };

var obj = Object.assign({}, o1, o2, o3);
console.log(obj); // { a: 1, b: 2, c: 3 }，屬性c為o3.c的值，最後一個出現的屬性c。
所有的屬性會被後方相同屬性名稱的值覆寫。
```
- combine o1, o2, o3 to an empty {}
- o2 will overwirte o1, o3 will overwrite o2, if they have the same properties.





