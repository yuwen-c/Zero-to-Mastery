## register route
```
app.post('/register', (req, res) => {
```
### SQL
- insert into a row of data(user), then return this user

### documentation
> // Returns [1] in "mysql", "sqlite", "oracle"; [] in "postgresql" unless the 'returning' parameter is set.                
> knex('books').insert({title: 'Slaughterhouse Five'})       
> Outputs:          
> insert into `books` (`title`) values ('Slaughterhouse Five')      

### code
```
app.post('/register', (req, res) => {
    const { name, email, password} = req.body;
    db('users')
    .returning("*")
    .insert({
        name: name,
        email: email,
        joined: new Date()
    })
    .then(user => res.json(user[0])) // w/o [0], it returns an array
    .catch(err => res.status(400).json("fail to register!!"));
})
```

### insert method:
```
.insert({
  key: value
  })
```
### returning method:
- ```('*')``` returns all columns of the user
- ```('name')``` returns only name column
- can be placed before or after ```insert```
- returning a ```[ ]```
> the returning method specifies which column should be returned by the INSERT and UPDATE methods.
***returning a PROMISE, use ```.then``` to access data***

***no need to user ```.json()``` since we don't pass it through HTTP***

### transaction    

#### documentation
> // Using trx as a query builder:    
> knex.transaction(function(trx) {    
> 
>   const books = [    
>     {title: 'Canterbury Tales'},    
>     {title: 'Moby Dick'},    
>     {title: 'Hamlet'}    
>   ];    
> 
>   return trx     
>     .insert({name: 'Old Books'}, 'id')    
>     .into('catalogues')    
>     .then(function(ids) {    
>       books.forEach((book) => book.catalogue_id = ids[0]);    
>       return trx('books').insert(books);    
>     });    
> })    
> .then(function(inserts) {    
>   console.log(inserts.length + ' new books saved.');    
> })    
> .catch(function(error) {    
>   // If we get here, that means that neither the 'Old Books' catalogues insert,    
>   // nor any of the books inserts will have taken place.    
>   console.error(error);    
> });    

- knex.transaction accepts a handler function with an argument, an object which may be used in two ways:

As the "promise aware" knex connection
As an object passed into a query with and eventually call commit or rollback.

## get user profile with id route
```
app.get('/profile/:id', (req, res)
```
- maybe for future function. some dev does this, write functionality which for now isn't be userd.

### SQL
- select from users where id =

### documentation
> knex.select('title', 'author', 'year').from('books')

### code
```
app.get('/profile/:id', (req, res) => {
    const { id } = req.params;
    db.select('*').from('users').where({
        id: id
    })
    .then(user => {
        if(user.length){
            res.json(user[0]);
        }
        else{
            res.status(400).json('user does not exit');
        }})
    .catch(error => res.status(400).json('cannot find user'));
})
```
- select from doesn't need a returning to return data
> the returning method specifies which column should be returned by the INSERT and UPDATE methods.

### return
- if no user is found, still return a ```[ ]``` 
- user ```user.length``` to check if any user is found


## update entries route
```
app.put('/image', (req, res)
```
- sending an url then increase the entries of user

### SQL
- UPDATE users SET entries = 1 WHERE id = 8;

### code
```
app.put('/image', (req, res) => {
    const { id } = req.body;
    db('users')
   .where({id: id})
   .returning('entries')
   .increment('entries', 1)
    .then(data => res.json(data));
})

```

### documentation
> knex('books')    
>   .where('published_date', '<', 2000)    
>   .update({    
>     status: 'archived',    
>     thisKeyIsSkipped: undefined    
>   })
  
> // Returns [ { id: 42, title: "The Hitchhiker's Guide to the Galaxy" } ]    
> knex('books')   
>   .where({ id: 42 })    
>   .update({ title: "The Hitchhiker's Guide to the Galaxy" }, ['id', 'title'])

- however, we want to do increment on entries.
### increment
> knex('accounts')
>   .where('userid', '=', 1)
>   .increment('balance', 10)
> Outputs:
> update `accounts` set `balance` = `balance` + 10 where `userid` = 1
- increment('COLUMN', 'GAP') (how many would you like to add every time)

### retunrning
> the returning method specifies which column should be returned by the INSERT and UPDATE methods.
- returning can also be used here.

## signIn route
