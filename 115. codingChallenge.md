#
結果早上那題 [數字的每個digit的連續次方數的總和]，別人的解答還滿有趣的。
先說我的：
```
// 例如：695 => 6² + 9³ + 5⁴= 1390 = 695 * 2
// 參數：n = 695; p = 2; 回傳最後一個"2" (695*2)，不整除回傳-1
function digPow(n, p){
// 很遜的數字轉string，再拆成數字的array
const str = n.toString();
let arr = [];
for(let i=0; i<str.length; i++){
arr.push(parseInt(str[i]))
}
// 算出連續次方的和：
let sum = 0;
for(let i=0; i<arr.length; i++){
sum = sum + arr[i]**(p);
p++;
}
// 三元運算，老是忘記前面要return!!!!!!! 煩吶
return sum%n===0 ? sum/n : -1
}
```
看到有趣的答案：
```
function digPow(n, p) {
var x = String(n).split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
return x % n ? -1 : x / n
}
```
直接用js會自動轉換string跟number的特性，拆成string array後就直接下去做了，不用轉number
要算總和，可以利用reduce! 太少用都忘了：
```
array.reduce((acc, item, index) => { }, starter)
```
剛好這些參數都用到了。
用我自己看得懂的寫法是：
```
const sum = a.reduce((accumulator, item, index) => {
return accumulator+item**(p+index)
}, 0)
```
判斷是否整除，我是用餘數% ===0，這個人用boolean，如果餘0，整除，就是false，有餘數，就是true，妙妙的。
