# Return的位置
- 想清楚，要在哪邊中斷function，要在if/else block裡面，還是外面？
(例如在for裡面return，for不會跑完，會中斷。如果在for外面，那跑完for，一定會去經過return。)
(如果在if/else外面，就一定會經過if/else後，再return，但如果是各條件下return，就應該寫在block裡面)
- 三元運算，前面不能忘記return。
- 三元運算寫法，如果直接是回傳true, false，就直接回傳那個問號等式就可以了。
- forEach裡面的return, default是undefined，就算寫了要return某個值，外面也收不到。
```
    array2.forEach((item, index) => {

      if(item === array1[index]**2){
        
      }
      else{
        return false;
      }
    return true;      
    })
// forEach return不會傳到外面，裡面寫再多return都沒有用，他的default就是return undefined
```

# 變數宣告的位置：
- 想想看我會在哪裡用到這個變數？block外面才會回傳嗎？還是裡面？

# 什麼時候需要變數宣告？ 當我需要「寄放」一個值的時候。
- 例如，要求得array中最小的數字的和。 我想：假設現在最小的兩個值是array[0], array[1]，跟其他相比之後，替換掉.... 
=>那就把「假設現在最小的兩個值，存在兩個變數裡」
- 例如，要把兩個array，依照大小放到另一個array中。 我想：現在先拿兩個值，array1[0], array2[0]，出來比，小的那個，就push進去，然後換下一個...
=>我需要兩個位置「寄放」要比較的東西，所以設```arrayItem1 = array1[0], arrayItem2 = array2[0]```，比完之後，再放下一個值進去那個位置。

# 什麼時候用for? 什麼時候用while? -- 兩者大部分情況是互通的！就看好不好寫而已。
**如果需要用一個計數器來決定圈數，就用for**\
**如果很難用一個計數器來決定圈數，可以考慮while**\
**如果 loop 內部運算會跟圈數(i)綁定，很適合用for**

> while 參考題：
> merge 兩個排序好的array，使他成為單一個排好序的array
> 每次挑兩個array的各一個來比較。

## 差異
- 跑幾圈？ for清楚知道會跑幾圈；while不知道，或「比較不重要」。
- 結束條件？ for的結束條件的調控就寫在(let i; i++)裡面；while 如果有結束條件的話，調控的變數是「宣告」在while外部。
- 圈數推進 與 內部計算 的關係? for loop 內部的計算與i(圈數)綁定，例如```array[i]*2``` ； while loop 的內部計算(推進)，與圈數各自獨立，如參考題，內部的推進是另外宣告x,y，跟圈數無關。

## 相似
- 裡面都可以再放if/else條件式，裡面都可以做不固定的事情。


##### nested for loop
- 還有我本來想的，用兩個for loop :
(因為我想到，兩個array，分別推進，所以就要有兩輪；彼此交互作用，所以nested)
也是行不通的，因為他不是固定1對多，2對多，3對多....


# 「有幾個條件」的思考模式？ => 先找到最通用的pattern
- 找到最通用的pattern之後，去思考，那如果其他比較少見的條件，用這個pattern套用，會符合嗎？
- 例如：比大小，可能 >, <, =，但是>. < 是比較常見的pattern，把這邊的處理方式想好之後，再去想，那如果=的話，這裡可以用嗎？

# 數字、字串的變換 convert array and string
- 不要濫用js coersion，會有無法預期的結果。
(例如：沒有轉成數字就去比大小，結果"6"比"542"大。)

## string -> array : split("")
```
const str = '4 5 29 54 4 0 -214 542 -64 1 -3 6 -6';
const arr = str.split(" "); //用空格分隔。
arr: [4, 5, 29, 54, 4, 0, -214, 542, -64, 1, -3, 6, -6]

但如果需要比大小，就需要轉成數字：
const numArr = arr.map(item => parseInt(item))
```

## array -> string : join("")
```
const arr = [4, 5, 29, 54, 4, 0, -214, 542, -64, 1, -3, 6, -6]
const str1 = arr.join(",");
str1 : "4,5,29,54,4,0,-214,542,-64,1,-3,6,-6"
const str2 = arr.join("");
str2 : "45295440-214542-641-36-6"
```
# 依序結帳題：
- clever solution! 其實頭幾名顧客並不是edge case!
```js
function queueTime(customers, n) {
  var w = new Array(n).fill(0);
  for (let t of customers) {
    let idx = w.indexOf(Math.min(...w));
    w[idx] += t;
  }
  return Math.max(...w);
}
```
- this was mine:
```js
function queueTime(customers, n) {
  if(customers.length === 0){
    return 0
  }
  else if(n > customers.length){
    return Math.max(...customers)
  }
  else{
    const sum = [];
    for(let i=0; i<n; i++){
      sum[i] = customers[i]
    }
    let c = n;
    while(c < customers.length){
      let minTill = sum.indexOf(Math.min(...sum))
      sum[minTill] = sum[minTill] + customers[c];
      c++;
    }
    return Math.max(...sum)
  }
}
```
- 怎麼說？雖然畫圖具象化是好事，可以幫助理解，但還是要試圖找出最根源的關鍵點。
- 其實從頭到尾，就是客戶要去前面「先結束」的櫃檯。重點是「先結束」跟「客戶一個個過去」，只需要考慮依序輪客戶的array即可。
**試著把關鍵用說出來的，或文字描寫出來，不要用算式，應該會有幫助。**


# 
結果早上那題 [數字的每個digit的連續次方數的總和]，別人的解答還滿有趣的。
先說我的：
```
// 例如：695 => 6² + 9³ + 5⁴= 1390 = 695 * 2
// 參數：n = 695; p = 2; 回傳最後一個"2" (695*2)，不整除回傳-1
function digPow(n, p){
// 很遜的數字轉string，再拆成數字的array
const str = n.toString();
let arr = [];
for(let i=0; i<str.length; i++){
arr.push(parseInt(str[i]))
}
// 算出連續次方的和：
let sum = 0;
for(let i=0; i<arr.length; i++){
sum = sum + arr[i]**(p);
p++;
}
// 三元運算，老是忘記前面要return!!!!!!! 煩吶
return sum%n===0 ? sum/n : -1
}
```
看到有趣的答案：
```
function digPow(n, p) {
var x = String(n).split("").reduce((s, d, i) => s + Math.pow(d, p + i), 0)
return x % n ? -1 : x / n
}
```
直接用js會自動轉換string跟number的特性，拆成string array後就直接下去做了，不用轉number
要算總和，可以利用reduce! 太少用都忘了：
```
array.reduce((acc, item, index) => { }, starter)
```
剛好這些參數都用到了。
用我自己看得懂的寫法是：
```
const sum = a.reduce((accumulator, item, index) => {
return accumulator+item**(p+index)
}, 0)
```
判斷是否整除，我是用餘數% ===0，這個人用boolean，如果餘0，整除，就是false，有餘數，就是true，妙妙的。


# 一些判斷
## 奇數偶數?
- bitwise&1竟然可以判斷奇數偶數

## 整數、小數?
- 判斷是否整除，我是用餘數% ===0，這個人用boolean，如果餘0，整除，就是false，有餘數，就是true，妙妙的。
```
return x % n ? -1 : x / n
```

## 十進位數字的拆解?  => 用餘數： %10, %100，除完餘多少 
- 把進位的數字拆解十多運用/10, %10


# template string包變數的寫法：不用+號


# RECURSION : Square pyramidal number 平方金字塔數字 
- Question:
numberSquares(2) ➞ 5
numberSquares(4) ➞ 30
numberSquares(5) ➞ 55
```
function numberSquares(n) {
	if(n===0){
		return 0
	}else{
		let sum = 0;
		for(let i=1; i<=n; i++ ){
			sum = sum +Math.pow(i, 2)
		}
		return sum
	}
}
```
- 如果用recursion的方法： 
5層的答案= 4層再加第5層 : recursionFun(n) = n**2 + recursionFun(n-1)
```
const numberSquares = n => n > 1? n**2 + numberSquares(n-1) : 1;
```


# .reduce()
**如果所有的item會交互作用，且最後會return單一一個作用完的值，就適合用reduce**
**reduce: 的()裡面包的第一個參數，是我照他的格式寫出的function；而function裡回傳的值，會中斷該function，然後reduce就會收到那個值，並執行reduce內部所設定好的function。最後才回傳總結果。它的語法結構是個nested function.**

- reduce的第二個參數是```initial value```初始值, which is optional.

**reduce的奇葩設計：沒有初始值的話，把第0個元素當初始值，並且直接從下一輪開始跑。**

[參考](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
> 「當回呼函式第一次被呼叫時，accumulator 與 currentValue 的值可能為兩種不同的狀況：
> 若在呼叫 reduce() 時有提供 initialValue，則 accumulator 將會等於 initialValue，且 currentValue 會等於陣列中的第一個元素值；
> 若沒有提供 initialValue，則 accumulator 會等於陣列的第一個元素值，且 currentValue 將會等於陣列的第二個元素值。」

## reduce 思考題：
> list([ {name: 'Bart'}, {name: 'Lisa'}, {name: 'Maggie'} ])
> // returns 'Bart, Lisa & Maggie'
> 
> list([ {name: 'Bart'}, {name: 'Lisa'} ])
> // returns 'Bart & Lisa'
> 
> list([ {name: 'Bart'} ])
> // returns 'Bart'
> 
> list([])
> // returns ''

```js
function list(names){
  return names.reduce(function(prev, current, index, array){
    if (index === 0){
      return current.name;
    }
    else if (index === array.length - 1){
      return prev + ' & ' + current.name;
    } 
    else {
      return prev + ', ' + current.name;
    }
  }, '');
 }
```
 
```js
 function list(names) {
    var result = "";
    var comma = ", ";
    var and = " & ";
    while (names.length) {
        result += names.shift().name;
        if (names.length == 1) {
            result += and;
        } else if (names.length > 1) {
            result += comma;
        }
    }

    return result;
}
```
 
```js
 function list( names ){
  return names.reduce(function(prev, curr, i, arr){
    return prev + curr.name + (i<arr.length-2?', ':i==arr.length-2?' & ':'');
  }, '');
}
```

- 我的很遜：
```js
function list(names){
  const len = names.length;
  if(names){
    if(len >=3){
      const nameValue = names.map(item => item.name);
      let str = '';
      for(let i=0; i<len-2; i++){  
        str = str + nameValue[i] + ", "
      }
      return `${str}${nameValue[len-2]} & ${nameValue[len-1]}`;
    }
    else if(len === 2){
      return `${names[0].name} & ${names[1].name}`;
    }
    else if(len === 1){
      return names[0].name;
    }
  }
  return ''
}
```
